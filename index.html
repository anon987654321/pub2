<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="mobile-web-app-capable" content="yes" />
    <title>Radio Bergen</title>
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Classic warp tunnel with multiple views. Swipe to explore. Tilt device for parallax." />
   
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìª</text></svg>">
   
    <style>
      html, body {
        margin: 0; height: 100%; background: #000; color: #9aa;
        font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        overflow: hidden;
      }
      canvas {
        position: fixed; inset: 0; width: 100vw; height: 100vh;
        display: block; background: #000; touch-action: none;
      }
     
      .loading-screen {
        position: fixed; inset: 0; background: #000; color: #9aa;
        display: grid; place-items: center; z-index: 2000;
        transition: opacity 0.5s ease;
      }
      .loading-screen.hidden { opacity: 0; pointer-events: none; }
     
      .city-carousel {
        position: fixed; top: 12px; left: 12px; width: 280px; height: 40px;
        z-index: 95; pointer-events: none; user-select: none; overflow: hidden;
      }
     
      .carousel-container {
        width: 100%; height: 100%; position: relative; overflow: hidden;
      }
      .carousel-slide {
        height: 100%; display: flex; align-items: center; justify-content: flex-start;
        font-weight: 700; font-size: clamp(24px, 3.2vw, 36px); color: #fff;
        letter-spacing: 0.02em; transition: all 0.3s ease;
        position: absolute; top: 0; left: 0; width: 100%;
        opacity: 0; transform: translateY(100%);
      }
      .carousel-slide.active { opacity: 1; transform: translateY(0%); }
      .city-inverted .carousel-slide { color: #000 !important; }
    
      .ui {
        position: fixed; right: 12px; bottom: 10px; color: #7a90a0; font-size: 12px;
        opacity: 0.95; white-space: nowrap; pointer-events: none; user-select: none;
        text-align: right; max-width: min(72vw, 800px); overflow: hidden;
        text-overflow: ellipsis; z-index: 100; transition: color 0.18s ease;
      }
      .ui-inverted { color: #445566 !important; }
     
      .overlay {
        position: fixed; inset: 0; display: grid; place-items: center;
        background: rgba(0,0,0,0.9); color: #9aa; cursor: pointer; user-select: none;
        z-index: 1000; text-align: center; padding: 16px;
      }
      .overlay[hidden] { display: none; }
    
      .overlay h2 {
        margin: 0 0 20px 0; font-size: 36px; font-weight: 300; color: #fff;
      }
    
      .instructions {
        position: absolute; bottom: 20px; right: 20px; font-size: 10px;
        color: #666; text-align: right; line-height: 1.4; max-width: 200px;
        display: grid; grid-template-columns: auto auto; gap: 4px 12px; justify-content: end;
      }
      .instructions span { white-space: nowrap; }
     
      #player {
        position: fixed; top: -1000px; left: -1000px; width: 1px; height: 1px;
        opacity: 0; pointer-events: none;
      }
     
      .viz-indicator {
        position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
        display: flex; gap: 8px; z-index: 99; pointer-events: none;
      }
      .viz-dot {
        width: 8px; height: 8px; border-radius: 50%; background: rgba(255,255,255,0.3);
        transition: background 0.3s ease;
      }
      .viz-dot.active { background: rgba(255,255,255,0.8); }
     
      .touch-ripple {
        position: absolute; width: 50px; height: 50px; border-radius: 50%;
        background: rgba(100,200,255,0.4); pointer-events: none;
        animation: ripple 0.6s ease-out forwards; z-index: 50;
      }
      @keyframes ripple {
        0% { transform: scale(0); opacity: 1; }
        100% { transform: scale(4); opacity: 0; }
      }
     
      .swipe-hint {
        position: fixed; bottom: 50px; left: 50%; transform: translateX(-50%);
        color: #555; font-size: 11px; opacity: 0; transition: opacity 0.5s ease; z-index: 99;
      }
      .swipe-hint.show { opacity: 1; }
     
      @media (prefers-reduced-motion: reduce) {
        * { animation: none !important; transition: none !important; }
        .touch-ripple { display: none; }
      }
     
      @media (max-width: 768px) {
        canvas { image-rendering: pixelated; }
        .city-carousel { width: 200px; }
        .carousel-slide { font-size: clamp(18px, 4vw, 28px); }
      }
    </style>
  </head>
  <body>
    <div class="loading-screen" id="loadingScreen">
      <div>üìª Loading Radio Bergen...</div>
    </div>
   
    <div class="city-carousel" id="cityCarousel">
      <div class="carousel-container">
        <div class="carousel-slide active">radio.brgen.no</div>
        <div class="carousel-slide">radio.oslo.no</div>
        <div class="carousel-slide">radio.trndheim.no</div>
        <div class="carousel-slide">radio.stvanger.no</div>
        <div class="carousel-slide">radio.trmso.no</div>
        <div class="carousel-slide">radio.longyearbyn.no</div>
        <div class="carousel-slide">radio.reykjavk.is</div>
        <div class="carousel-slide">radio.kobenhvn.dk</div>
        <div class="carousel-slide">radio.stholm.se</div>
        <div class="carousel-slide">radio.gtebrg.se</div>
        <div class="carousel-slide">radio.mlmoe.se</div>
        <div class="carousel-slide">radio.hlsinki.fi</div>
        <div class="carousel-slide">radio.lndon.uk</div>
        <div class="carousel-slide">radio.cardff.uk</div>
        <div class="carousel-slide">radio.mnchester.uk</div>
        <div class="carousel-slide">radio.brmingham.uk</div>
        <div class="carousel-slide">radio.lverpool.uk</div>
        <div class="carousel-slide">radio.edinbrgh.uk</div>
        <div class="carousel-slide">radio.glasgw.uk</div>
        <div class="carousel-slide">radio.amstrdam.nl</div>
        <div class="carousel-slide">radio.rottrdam.nl</div>
        <div class="carousel-slide">radio.utrcht.nl</div>
        <div class="carousel-slide">radio.brssels.be</div>
        <div class="carousel-slide">radio.zrich.ch</div>
        <div class="carousel-slide">radio.lchtenstein.li</div>
        <div class="carousel-slide">radio.frankfrt.de</div>
        <div class="carousel-slide">radio.wrsawa.pl</div>
        <div class="carousel-slide">radio.gdnsk.pl</div>
        <div class="carousel-slide">radio.brdeaux.fr</div>
        <div class="carousel-slide">radio.mrseille.fr</div>
        <div class="carousel-slide">radio.mlan.it</div>
        <div class="carousel-slide">radio.lsbon.pt</div>
        <div class="carousel-slide">radio.lsangeles.com</div>
        <div class="carousel-slide">radio.newyrk.us</div>
        <div class="carousel-slide">radio.chcago.us</div>
        <div class="carousel-slide">radio.houstn.us</div>
        <div class="carousel-slide">radio.dllas.us</div>
        <div class="carousel-slide">radio.austn.us</div>
        <div class="carousel-slide">radio.prtland.com</div>
        <div class="carousel-slide">radio.mnneapolis.com</div>
      </div>
    </div>
   
    <canvas id="canvas" aria-label="Classic warp tunnel visualizer"></canvas>
   
    <div id="overlay" class="overlay" role="dialog" aria-labelledby="start-title" tabindex="0">
      <div>
        <h2 id="start-title">Tap to start</h2>
        <div class="instructions">
          <span>Space: next</span> <span>M: mute</span>
          <span>Swipe: explore</span> <span>Tilt: parallax</span>
          <span>Double-tap: next</span>
        </div>
      </div>
    </div>
   
    <div class="viz-indicator" id="vizIndicator">
      <div class="viz-dot active"></div>
      <div class="viz-dot"></div>
      <div class="viz-dot"></div>
      <div class="viz-dot"></div>
    </div>
    <div class="ui" id="ui">Ready</div>
    <div class="swipe-hint" id="swipeHint">‚Üê Swipe for tracks ‚Üí</div>
    <iframe id="player" src="about:blank" frameborder="0" allow="autoplay; encrypted-media"></iframe>
   
    <script>
      "use strict";
     
      // Performance optimizations
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const isLowEnd = (navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 2) ||
                       (navigator.deviceMemory && navigator.deviceMemory <= 2);
     
      const QUALITY_SCALE = isLowEnd ? 0.6 : isMobile ? 0.8 : 1;
      const PARTICLE_COUNT = isLowEnd ? 12 : isMobile ? 18 : 25;
      const SPIRAL_COUNT = isLowEnd ? 3 : 4;
     
      // Simple Carousel
      class SimpleCarousel {
        constructor(element) {
          this.container = element;
          this.slides = Array.from(element.querySelectorAll('.carousel-slide'));
          this.currentIndex = 0;
          this.totalSlides = this.slides.length;
          this.init();
        }
       
        init() {
          this.startAutoplay();
        }
       
        goToSlide(index) {
          this.slides[this.currentIndex].classList.remove('active');
          this.currentIndex = ((index % this.totalSlides) + this.totalSlides) % this.totalSlides;
          this.slides[this.currentIndex].classList.add('active');
        }
       
        next() { this.goToSlide(this.currentIndex + 1); }
        prev() { this.goToSlide(this.currentIndex - 1); }
       
        startAutoplay() {
          this.autoplayInterval = setInterval(() => this.next(), 2800);
        }
       
        destroy() {
          if (this.autoplayInterval) clearInterval(this.autoplayInterval);
        }
      }
     
      // Tracks
      const YOUTUBE_TRACKS = [
        { artist: "J Dilla", title: "Microphone Master", id: "9EGHwkDix78" },
        { artist: "J Dilla", title: "In Space", id: "vO2nWXCVt6o" },
        { artist: "J Dilla", title: "Timeless", id: "dbbfo9_7D8g" },
        { artist: "Pachanga Boys", title: "Time", id: "2e21NOp69hM" },
        { artist: "Shaolin Cowboy", title: "Kate Moss", id: "AmxVbZpIf1E" },
        { artist: "FLYamSAM", title: "The Offbeat", id: "5SdMIa5vd4A" },
        { artist: "AFTA-1", title: "Due Time", id: "WC09qDzU9y4" },
        { artist: "Flying Lotus", title: "Message Situation", id: "9fzGGbiJags" },
        { artist: "R√∂yksopp", title: "Only This Moment", id: "vLE5XCc0XO8" },
        { artist: "Jneiro Jarel", title: "Chinubian", id: "9OPypHXlJUQ" },
        { artist: "Pete Rock", title: "A Little Soul", id: "4tY89H5TWPY" },
        { artist: "Slum Village", title: "La La (Instrumental)", id: "EYJxxHQ7sX0" },
        { artist: "Slum Village", title: "Get It Together", id: "t6T-Q6HMbEo" },
        { artist: "Slum Village", title: "Fantastic", id: "j0z_-7TfPeM" },
        { artist: "Flying Lotus", title: "me Yesterday//Corded", id: "8DgAhgmpXNA" },
        { artist: "Flying Lotus", title: "Camel", id: "t6SXXx1Fu_4" },
        { artist: "Slum Village", title: "Worlds Full of Sadness", id: "MU3nfxsz2XA" },
        { artist: "Bob Marley", title: "Forever Loving Jah", id: "WFCh0Ycjd4Q" }
      ];
     
      const UI = (() => {
        const el = document.getElementById("ui");
        return { text: (t) => { if (el) el.textContent = t; } };
      })();
     
      // Audio Engine
      class AudioEngine {
        constructor() {
          this.player = document.getElementById("player");
          this.started = false;
          this.muted = true;
          this.trackIndex = 0;
          this.tracks = [...YOUTUBE_TRACKS];
          this.startMs = 0;
          this._advanceTimer = null;
          this.beatPhase = 0;
          this.energyLevel = 0.5;
        }
      
        loadAndPlay(track) {
          if (!this.player) return;
          const { id } = track;
          const src = `https://www.youtube.com/embed/${id}?autoplay=1&controls=0&disablekb=1&fs=0&iv_load_policy=3&modestbranding=1&rel=0&playsinline=1&mute=1`;
          this.player.src = src;
          this.player.onload = () => {
            this.afterStart();
            setTimeout(() => {
              try {
                this.player.contentWindow.postMessage({event: 'command', func: 'unMute', args: []}, '*');
                this.muted = false;
                UI.text(this.trackLabel());
              } catch(e) {
                UI.text(this.trackLabel() + " ‚Ä¢ muted");
              }
            }, 1000);
          };
          this.beatPhase = Math.random() * Math.PI * 2;
        }
      
        afterStart() {
          this.startMs = performance.now();
          clearTimeout(this._advanceTimer);
          this._advanceTimer = setTimeout(() => this.next(), 180000);
        }
      
        next() {
          this.trackIndex = (this.trackIndex + 1) % this.tracks.length;
          this.loadAndPlay(this.tracks[this.trackIndex]);
        }
      
        prev() {
          this.trackIndex = (this.trackIndex - 1 + this.tracks.length) % this.tracks.length;
          this.loadAndPlay(this.tracks[this.trackIndex]);
        }
      
        toggleMute() {
          this.muted = !this.muted;
          try {
            const command = this.muted ? 'mute' : 'unMute';
            this.player.contentWindow.postMessage({event: 'command', func: command, args: []}, '*');
            UI.text(this.trackLabel() + (this.muted ? " ‚Ä¢ muted" : ""));
          } catch(e) {
            console.log('Could not toggle mute');
          }
        }
      
        trackLabel() {
          const t = this.tracks[this.trackIndex];
          return `${t.artist} ‚Äî ${t.title}`;
        }
      
        data() {
          this.beatPhase += 0.08;
          this.energyLevel = this.energyLevel * 0.999 + Math.random() * 0.001;
        
          const bass = 0.4 + 0.4 * Math.sin(this.beatPhase * 0.8);
          const mid = 0.35 + 0.35 * Math.sin(this.beatPhase * 1.2);
          const high = 0.25 + 0.35 * Math.sin(this.beatPhase * 1.8);
          const avg = (bass + mid + high) / 3;
          const beat = Math.sin(this.beatPhase) > 0.7 ? 1 : 0;
        
          return { bass, mid, high, average: avg, beat, energy: this.energyLevel };
        }
      }
     
      const audio = new AudioEngine();
      let carousel;
     
      // Canvas
      let w = 0, h = 0, canvas, ctx, imageData, data;
      let resizeTimeout;
     
      canvas = document.getElementById("canvas");
      ctx = canvas.getContext("2d", { alpha: false, willReadFrequently: true });
     
      function onResize() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          w = Math.floor(window.innerWidth * QUALITY_SCALE);
          h = Math.floor(window.innerHeight * QUALITY_SCALE);
          canvas.width = w;
          canvas.height = h;
          canvas.style.width = window.innerWidth + 'px';
          canvas.style.height = window.innerHeight + 'px';
          ctx.fillStyle = "#000";
          ctx.fillRect(0, 0, w, h);
          imageData = ctx.getImageData(0, 0, w, h);
          data = imageData.data;
         
          if (vizManager.initialized) vizManager.init();
        }, 100);
      }
     
      window.addEventListener("resize", onResize, { passive: true });
     
      // Pixel operations
      function clearImageData() {
        data.fill(0);
        for (let i = 3; i < data.length; i += 4) data[i] = 255;
      }
    
      function setPixel(x, y, r, g, b) {
        if (x < 0 || x >= w || y < 0 || y >= h) return;
        const i = (Math.floor(x) + Math.floor(y) * w) * 4;
        data[i] = r; data[i + 1] = g; data[i + 2] = b; data[i + 3] = 255;
      }
    
      function drawLine(x1, y1, x2, y2, r, g, b, thickness = 1) {
        const dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1);
        const sx = x1 < x2 ? 1 : -1, sy = y1 < y2 ? 1 : -1;
        let err = dx - dy, x = x1, y = y1;
      
        while (true) {
          if (thickness === 1) {
            setPixel(x, y, r, g, b);
          } else {
            const t = Math.floor(thickness);
            for (let tx = -t; tx <= t; tx++) {
              for (let ty = -t; ty <= t; ty++) {
                if (tx * tx + ty * ty <= t * t) {
                  setPixel(x + tx, y + ty, r, g, b);
                }
              }
            }
          }
        
          if (x === x2 && y === y2) break;
          const e2 = err * 2;
          if (e2 > -dy) { err -= dy; x += sx; }
          if (e2 < dx) { err += dx; y += sy; }
        }
      }
      // Simple multi-visualizer system
      class VisualizerManager {
        constructor() {
          this.currentViz = 0;
          this.initialized = false;
          this.visualizers = [];
        }
      
        init() {
          this.visualizers = [
            new TunnelVisualizer(),
            new SimpleSpiralsVisualizer(),
            new SimpleWavesVisualizer(),
            new SimpleDotsVisualizer()
          ];
          this.visualizers.forEach(viz => viz.init());
          this.updateIndicator();
          this.initialized = true;
        }
      
        switchTo(index) {
          if (index >= 0 && index < this.visualizers.length && index !== this.currentViz) {
            this.currentViz = index;
            this.updateIndicator();
          }
        }
      
        next() {
          this.switchTo((this.currentViz + 1) % this.visualizers.length);
        }
      
        prev() {
          this.switchTo((this.currentViz - 1 + this.visualizers.length) % this.visualizers.length);
        }
      
        updateIndicator() {
          const dots = document.querySelectorAll('.viz-dot');
          dots.forEach((dot, i) => {
            dot.classList.toggle('active', i === this.currentViz);
          });
        }
      
        render(audioData) {
          if (this.initialized && this.visualizers[this.currentViz]) {
            this.visualizers[this.currentViz].render(audioData);
          }
        }
      }
     
      class TunnelVisualizer {
        constructor() {
          this.particles = [];
          this.centers = [];
          this.floatingParticles = [];
          this.time = 0;
          this.fov = 250;
          this.speed = 0.8;
          this.segments = isLowEnd ? 12 : 20;
          this.baseRadius = 80;
          this.zStep = isLowEnd ? 15 : 10;
        }
      
        init() {
          this.particles = [];
          this.centers = [];
          this.floatingParticles = [];
        
          for (let z = -this.fov; z < this.fov; z += this.zStep) {
            const row = [];
            const center = { x: w / 2, y: h / 2 };
            this.centers.push(center);
            for (let i = 0; i <= this.segments; i++) {
              const angle = i * ((Math.PI * 2) / this.segments);
              const x = Math.cos(angle) * this.baseRadius;
              const y = Math.sin(angle) * this.baseRadius;
              row.push({ x, y, z, x2d: 0, y2d: 0, radius: this.baseRadius, radiusAudio: this.baseRadius, index: i });
            }
            this.particles.push(row);
          }
        
          for (let i = 0; i < PARTICLE_COUNT; i++) {
            this.floatingParticles.push(new FloatingParticle());
          }
        }
      
        render(audioData) {
          const rows = this.particles.length;
          let mx = 0, my = 0;
          if (mouseActive || mouseDown) {
            mx = (w / 2 - mousePos.x);
            my = (h / 2 - mousePos.y);
          } else if (orientationActive) {
            mx = -gamma * (w / 180);
            my = -beta * (h / 180);
          }
         
          for (let i = 0; i < rows; i++) {
            const row = this.particles[i];
            const center = this.centers[i];
            center.x = mx * ((row[0].z - this.fov) / 500) + w / 2;
            center.y = my * ((row[0].z - this.fov) / 500) + h / 2;
           
            for (let j = 0, k = row.length; j < k; j++) {
              const p = row[j];
              const scale = this.fov / (this.fov + p.z);
              p.x2d = (p.x * scale) + center.x;
              p.y2d = (p.y * scale) + center.y;
              p.radiusAudio = p.radius + audioData.average * 10 + (audioData.beat ? 15 : 0);
              p.z -= this.speed;
              if (p.z < -this.fov) p.z += (this.fov * 2);
             
              const depthFactor = (p.z + this.fov) / (this.fov * 2);
              const r = Math.round(20 + depthFactor * 100);
              const g = Math.round(60 + depthFactor * 140);
              const b = Math.round(120 + depthFactor * 135);
              const thickness = 1 + Math.round(audioData.energy * 2);
            
              if (j > 0) {
                const pPrev = row[j - 1];
                drawLine(
                  Math.round(p.x2d), Math.round(p.y2d),
                  Math.round(pPrev.x2d), Math.round(pPrev.y2d),
                  r, g, b, thickness
                );
              }
             
              const angle = p.index * ((Math.PI * 2) / this.segments) + this.time;
              p.x = Math.cos(angle) * p.radiusAudio;
              p.y = Math.sin(angle) * p.radiusAudio;
             
              if (i > 0) {
                const pB = this.particles[i-1][j] || this.particles[i-1][0];
                drawLine(
                  Math.round(p.x2d), Math.round(p.y2d),
                  Math.round(pB.x2d), Math.round(pB.y2d),
                  r, g, b, Math.max(1, thickness - 1)
                );
              }
            }
          }
         
          this.floatingParticles.forEach(particle => {
            particle.update(audioData);
            particle.render(w / 2, h / 2, audioData);
          });
         
          this.time += 0.01;
        }
      }
     
      class SimpleSpiralsVisualizer {
        constructor() {
          this.time = 0;
          this.spirals = [];
        }
       
        init() {
          for (let i = 0; i < SPIRAL_COUNT; i++) {
            this.spirals.push({
              centerX: w / 2 + (Math.random() - 0.5) * w * 0.3,
              centerY: h / 2 + (Math.random() - 0.5) * h * 0.3,
              rotation: Math.random() * Math.PI * 2,
              speed: 0.02 + Math.random() * 0.03,
              arms: 3 + Math.floor(Math.random() * 4)
            });
          }
        }
       
        render(audioData) {
          this.time += 0.02;
          let mx = 0, my = 0;
          if (mouseActive || mouseDown) {
            mx = (w / 2 - mousePos.x);
            my = (h / 2 - mousePos.y);
          } else if (orientationActive) {
            mx = -gamma * (w / 180);
            my = -beta * (h / 180);
          }
         
          this.spirals.forEach((spiral) => {
            spiral.rotation += spiral.speed * (1 + audioData.energy);
            spiral.centerX = w / 2 + mx * 0.2;
            spiral.centerY = h / 2 + my * 0.2;
           
            const baseRadius = Math.min(w, h) * 0.2;
            const maxRadius = baseRadius * (1 + audioData.average);
           
            for (let arm = 0; arm < spiral.arms; arm++) {
              const armAngle = (arm / spiral.arms) * Math.PI * 2;
              for (let r = 10; r < maxRadius; r += isLowEnd ? 12 : 10) {
                const angle = spiral.rotation + armAngle + r * 0.02;
                const x = spiral.centerX + Math.cos(angle) * r;
                const y = spiral.centerY + Math.sin(angle) * r;
               
                const intensity = (1 - r / maxRadius) * (1 + audioData.beat * 0.5);
                const red = Math.round(100 + intensity * 100);
                const green = Math.round(150 + intensity * 80);
                const blue = Math.round(200 + intensity * 55);
               
                const size = 2 + intensity * 3;
                for (let dx = -size; dx <= size; dx++) {
                  for (let dy = -size; dy <= size; dy++) {
                    if (dx*dx + dy*dy <= size*size) {
                      setPixel(Math.round(x + dx), Math.round(y + dy), red, green, blue);
                    }
                  }
                }
              }
            }
          });
        }
      }
     
      class SimpleWavesVisualizer {
        constructor() { this.time = 0; }
        init() {}
        render(audioData) {
          this.time += 0.03;
          let mx = 0, my = 0;
          if (mouseActive || mouseDown) {
            mx = (w / 2 - mousePos.x);
            my = (h / 2 - mousePos.y);
          } else if (orientationActive) {
            mx = -gamma * (w / 180);
            my = -beta * (h / 180);
          }
          let centerX = w / 2 + mx * 0.3;
          let centerY = h / 2 + my * 0.3;
          const waveCount = isLowEnd ? 5 : 7;
          for (let wave = 0; wave < waveCount; wave++) {
            const wavePhase = (wave / waveCount) * Math.PI * 2;
            const radius = 50 + wave * 30 + audioData.average * 100;
           
            const points = [];
            const segments = isLowEnd ? 24 : 36;
           
            for (let i = 0; i <= segments; i++) {
              const angle = (i / segments) * Math.PI * 2;
              const waveOffset = Math.sin(angle * 3 + this.time + wavePhase) * audioData.energy * 20;
              const r = radius + waveOffset;
           
              const x = centerX + Math.cos(angle) * r;
              const y = centerY + Math.sin(angle) * r;
              points.push({ x, y });
            }
           
            const intensity = (wave / waveCount) + audioData.beat * 0.3;
            const red = Math.round(50 + intensity * 150);
            const green = Math.round(100 + intensity * 120);
            const blue = Math.round(200 + intensity * 55);
           
            for (let i = 0; i < points.length - 1; i++) {
              const p1 = points[i];
              const p2 = points[i + 1];
           
              drawLine(
                Math.round(p1.x), Math.round(p1.y),
                Math.round(p2.x), Math.round(p2.y),
                red, green, blue, 1 + Math.round(audioData.energy * 2)
              );
            }
          }
        }
      }
     
      class SimpleDotsVisualizer {
        constructor() {
          this.dots = [];
          this.time = 0;
        }
       
        init() {
          const gridSize = isLowEnd ? 60 : 45;
          for (let x = gridSize; x < w; x += gridSize) {
            for (let y = gridSize; y < h; y += gridSize) {
              this.dots.push({
                x: x,
                y: y,
                phase: Math.random() * Math.PI * 2,
                speed: 0.05 + Math.random() * 0.05
              });
            }
          }
        }
       
        render(audioData) {
          this.time += 0.02;
          let mx = 0, my = 0;
          if (mouseActive || mouseDown) {
            mx = (w / 2 - mousePos.x);
            my = (h / 2 - mousePos.y);
          } else if (orientationActive) {
            mx = -gamma * (w / 180);
            my = -beta * (h / 180);
          }
         
          this.dots.forEach(dot => {
            dot.phase += dot.speed * (1 + audioData.energy);
           
            const distance = Math.sqrt((dot.x - w/2) * (dot.x - w/2) + (dot.y - h/2) * (dot.y - h/2));
            const maxDistance = Math.sqrt(w*w + h*h) / 2;
            const normalizedDistance = distance / maxDistance;
           
            const size = (1 - normalizedDistance) * (3 + audioData.average * 8 + Math.sin(dot.phase) * 2);
            const intensity = (1 - normalizedDistance) * (0.5 + audioData.beat * 0.5 + Math.sin(dot.phase + this.time) * 0.3);
           
            if (size > 0.5 && intensity > 0.1) {
              const red = Math.round(intensity * 200);
              const green = Math.round(intensity * 150);
              const blue = Math.round(intensity * 255);
           
              const x = dot.x + mx * 0.1;
              const y = dot.y + my * 0.1;
              const sizeInt = Math.round(size);
              for (let dx = -sizeInt; dx <= sizeInt; dx++) {
                for (let dy = -sizeInt; dy <= sizeInt; dy++) {
                  if (dx*dx + dy*dy <= sizeInt*sizeInt) {
                    setPixel(Math.round(x + dx), Math.round(y + dy), red, green, blue);
                  }
                }
              }
            }
          });
        }
      }
      const vizManager = new VisualizerManager();
      // Simple sensor handling
      let orientationActive = false, beta = 0, gamma = 0;
     
      function setupSimpleSensors() {
        try {
          if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission().then(state => {
              if (state === 'granted') {
                window.addEventListener("deviceorientation", (e) => {
                  beta = e.beta || 0;
                  gamma = e.gamma || 0;
                  orientationActive = true;
                }, { passive: true });
              }
            }).catch(console.error);
          } else if (window.DeviceOrientationEvent) {
            window.addEventListener("deviceorientation", (e) => {
              beta = e.beta || 0;
              gamma = e.gamma || 0;
              orientationActive = true;
            }, { passive: true });
          }
        } catch(e) { console.error(e); }
      }
      // Touch handling
      let mouseActive = false, mouseDown = false;
      let mousePos = { x: w/2, y: h/2 };
      let touchStartX = 0, touchStartY = 0, lastTapTime = 0;
      const swipeThreshold = 70, doubleTapMs = 300;
      const swipeHint = document.getElementById("swipeHint");
      function createRipple(x, y) {
        const ripple = document.createElement('div');
        ripple.className = 'touch-ripple';
        ripple.style.left = (x - 25) + 'px';
        ripple.style.top = (y - 25) + 'px';
        document.body.appendChild(ripple);
        setTimeout(() => ripple.remove(), 600);
      }
      // Mouse events
      canvas.addEventListener('mousedown', () => { mouseDown = true; setInversion(true); }, false);
      canvas.addEventListener('mouseup', () => { mouseDown = false; setInversion(false); }, false);
      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        mousePos.x = e.clientX - rect.left;
        mousePos.y = e.clientY - rect.top;
        mouseActive = true;
      }, false);
      canvas.addEventListener('mouseleave', () => {
        mouseActive = false;
        mouseDown = false;
        setInversion(false);
      }, false);
      // Touch events
      canvas.addEventListener("touchstart", (e) => {
        e.preventDefault();
        const t = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const x = t.clientX - rect.left, y = t.clientY - rect.top;
        touchStartX = x; touchStartY = y;
        mousePos.x = x; mousePos.y = y;
        mouseDown = true; setInversion(true);
        createRipple(x, y);
        const now = performance.now();
        if (now - lastTapTime < doubleTapMs && audio.started) {
          audio.next(); UI.text(audio.trackLabel());
        }
        lastTapTime = now;
      }, { passive: false });
      canvas.addEventListener("touchmove", (e) => {
        e.preventDefault();
        const t = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        mousePos.x = t.clientX - rect.left;
        mousePos.y = t.clientY - rect.top;
      }, { passive: false });
      canvas.addEventListener("touchend", (e) => {
        e.preventDefault();
        mouseDown = false; setInversion(false);
        if (audio.started) {
          const t = e.changedTouches[0];
          const rect = canvas.getBoundingClientRect();
          const endX = t.clientX - rect.left, endY = t.clientY - rect.top;
          const dx = endX - touchStartX, dy = endY - touchStartY;
         
          if (Math.abs(dx) > swipeThreshold || Math.abs(dy) > swipeThreshold) {
            if (Math.abs(dx) > Math.abs(dy)) {
              // Horizontal swipe - change tracks
              if (dx > 0) audio.prev(); else audio.next();
              UI.text(audio.trackLabel());
            } else {
              // Vertical swipe - change visualizers
              if (dy > 0) vizManager.next(); else vizManager.prev();
              const vizNames = ['Warp Tunnel', 'Spirals', 'Waves', 'Dots'];
              swipeHint.textContent = vizNames[vizManager.currentViz];
              swipeHint.classList.add('show');
              setTimeout(() => swipeHint.classList.remove('show'), 1400);
            }
          }
        }
      }, { passive: false });
      // Keyboard
      addEventListener("keydown", (e) => {
        if (e.code === "Space") { e.preventDefault(); if (audio.started) { audio.next(); UI.text(audio.trackLabel()); } return; }
        if (e.key?.toLowerCase() === "m") { e.preventDefault(); if (audio.started) audio.toggleMute(); return; }
        if (e.code === "ArrowRight") { e.preventDefault(); if (audio.started) { audio.next(); UI.text(audio.trackLabel()); } return; }
        if (e.code === "ArrowLeft") { e.preventDefault(); if (audio.started) { audio.prev(); UI.text(audio.trackLabel()); } return; }
        if (e.code === "ArrowUp") { e.preventDefault(); if (audio.started) vizManager.prev(); return; }
        if (e.code === "ArrowDown") { e.preventDefault(); if (audio.started) vizManager.next(); return; }
      });
      // Overlay
      const overlay = document.getElementById("overlay");
      overlay.addEventListener("click", (e) => { e.stopPropagation(); e.preventDefault(); startApp(); });
      overlay.addEventListener("keydown", (e) => { if (e.code === "Enter" || e.code === "Space") { e.preventDefault(); startApp(); } });
      function startApp() {
        if (!audio.started) {
          audio.started = true;
          audio.loadAndPlay(audio.tracks[audio.trackIndex]);
          overlay.hidden = true;
         
          // No citySwiper, as it's now Stimulus
        }
      }
      // Inversion
      let colorInvertValue = 0;
      const cityCarousel = document.getElementById("cityCarousel");
      function setInversion(active) {
        if (active) {
          cityCarousel.classList.add('city-inverted');
          document.getElementById('ui').classList.add('ui-inverted');
        } else {
          cityCarousel.classList.remove('city-inverted');
          document.getElementById('ui').classList.remove('ui-inverted');
        }
      }
     
      function softInvert(value) {
        for (let j = 0, n = data.length; j < n; j += 4) {
          data[j] = Math.abs(value - data[j]);
          data[j+1] = Math.abs(value - data[j+1]);
          data[j+2] = Math.abs(value - data[j+2]);
        }
      }
      // Main render loop (simple)
      function renderFrame(audioData) {
        if (mouseDown) {
          colorInvertValue = Math.min(255, colorInvertValue + 8);
          softInvert(colorInvertValue);
        } else {
          colorInvertValue = Math.max(0, colorInvertValue - 8);
          if (colorInvertValue > 0) softInvert(colorInvertValue);
        }
       
        vizManager.render(audioData);
      }
      function animate() {
        clearImageData();
        const audioData = audio.started ? audio.data() : {
          average: 0, bass: 0, mid: 0, high: 0, beat: false, energy: 0
        };
        renderFrame(audioData);
        ctx.putImageData(imageData, 0, 0);
        requestAnimationFrame(animate);
      }
      function boot() {
        onResize();
        setupSimpleSensors();
        vizManager.init();
       
        clearImageData();
        renderFrame({ average: 0, bass: 0, mid: 0, high: 0, beat: false, energy: 0 });
        ctx.putImageData(imageData, 0, 0);
       
        UI.text("Ready");
        requestAnimationFrame(animate);
      }
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", boot);
      } else {
        boot();
      }
    </script>
  </body>
</html>
