<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta name="mobile-web-app-capable" content="yes" />
  <title>Radio Brgen</title>
  <meta name="theme-color" content="#000000" />
  <meta name="description" content="Classic clean warp tunnel. Space: next track. M: mute/unmute. Mobile: swipe for tracks, double-tap next, touch invert, tilt parallax." />
  <style>
    html, body { margin: 0; height: 100%; background: #000; color: #9aa; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    canvas { position: fixed; inset: 0; width: 100vw; height: 100vh; display: block; background: #000; touch-action: none; }

    h1.site {
      position: fixed; top: 12px; left: 12px; margin: 0; color: #fff; letter-spacing: 0.02em;
      pointer-events: none; user-select: none; font-weight: 700; font-size: clamp(18px, 2.4vw, 26px);
      z-index: 100; transition: color 0.18s ease;
    }
    .site-inverted { color: #000 !important; }
    .ui { position: fixed; right: 12px; bottom: 10px; color: #7a90a0; font-size: 12px; opacity: 0.95; white-space: nowrap; pointer-events: none; user-select: none; text-align: right; max-width: min(72vw, 800px); overflow: hidden; text-overflow: ellipsis; z-index: 100; transition: color 0.18s ease; }
    .ui-inverted { color: #445566 !important; }

    .overlay { position: fixed; inset: 0; display: grid; place-items: center; background: rgba(0,0,0,0.9); color: #9aa; cursor: pointer; user-select: none; z-index: 1000; text-align: center; padding: 16px; }
    .overlay[hidden] { display: none; }

    #player { position: fixed; top: -1000px; left: -1000px; width: 1px; height: 1px; opacity: 0; pointer-events: none; }

    .touch-ripple { position: absolute; width: 50px; height: 50px; border-radius: 50%; background: rgba(255,255,255,0.28); pointer-events: none; animation: ripple 0.6s ease-out forwards; z-index: 50; }
    @keyframes ripple { 0% { transform: scale(0); opacity: 1; } 100% { transform: scale(4); opacity: 0; } }

    .swipe-hint { position: fixed; bottom: 50px; left: 50%; transform: translateX(-50%); color: #555; font-size: 11px; opacity: 0; transition: opacity 0.5s ease; z-index: 99; }
    .swipe-hint.show { opacity: 1; }

    @media (prefers-reduced-motion: reduce) {
      * { animation: none !important; transition: none !important; }
      .touch-ripple { display: none; }
    }
  </style>
</head>
<body>
  <h1 class="site" id="siteTitle" aria-hidden="true">radio.brgen.no</h1>
  <canvas id="canvas" aria-label="Classic warp tunnel visualizer"></canvas>

  <div id="overlay" class="overlay" role="dialog" aria-labelledby="start-title" tabindex="0">
    <h2 id="start-title" style="position:absolute;left:-9999px;">Start</h2>
    <p>
      Click / tap to start<br/>
      Space: next • M: mute<br/>
      Mobile: swipe left/right for tracks • double-tap: next • tilt for parallax
    </p>
  </div>

  <div class="ui" id="ui">Ready</div>
  <div class="swipe-hint" id="swipeHint">← Swipe for tracks →</div>
  <iframe id="player" src="about:blank" frameborder="0" allow="autoplay; encrypted-media; accelerometer; gyroscope"></iframe>

  <script>
    "use strict";

    // Exact curated tracks (preserved)
    const YOUTUBE_TRACKS = [
      { artist: "J Dilla", title: "Microphone Master", id: "9EGHwkDix78" },
      { artist: "AFTA-1", title: "Due Time", id: "WC09qDzU9y4" },
      { artist: "Flying Lotus", title: "Message Situation", id: "9fzGGbiJags" },
      { artist: "Röyksopp", title: "Only This Moment (Forsiktige massage)", id: "vLE5XCc0XO8" },
      { artist: "Jneiro Jarel", title: "Chinubian", id: "9OPypHXlJUQ" },
      { artist: "Pete Rock", title: "A Little Soul", id: "4tY89H5TWPY" },
      { artist: "Slum Village", title: "La La (Instrumental)", id: "EYJxxHQ7sX0" },
      { artist: "Slum Village", title: "Forth & Back (Rock Music) Instrumental", id: "1XY8EHOzLbY" },
      { artist: "Flying Lotus", title: "me Yesterday//Corded", id: "8DgAhgmpXNA" },
      { artist: "Flying Lotus", title: "Camel", id: "t6SXXx1Fu_4" },
      { artist: "Slum Village", title: "Worlds Full of Sadness", id: "MU3nfxsz2XA" },
      { artist: "Black Loops", title: "Under the Sea", id: "U81xh9gJeYM" }
    ];
    const WHYP_TRACKS = [
      { artist: "how", title: "J Dilla - Players (Second Version) (Unreleased)", id: "292777", token: "zaB8x" },
      { artist: "how", title: "Black Loops - Under the Sea [U81xh9gJeYM]", id: "292774", token: "UTbNQ" },
      { artist: "how", title: "amiga", id: "292741", token: "2Jh5p" },
      { artist: "how", title: "RADIO BERGEN #1", id: "292718", token: "1cr3I" },
      { artist: "how", title: "RAUINGAR", id: "230366", token: "zPfQp" },
      { artist: "how", title: "Haisam & Johann - PB1", id: "195489", token: "3XYFb" },
      { artist: "how", title: "Mike T & Johann - Alt Kan Skje", id: "183204", token: "20RKB" },
      { artist: "how", title: "Jan Hakim & Johann - Stailings (a)", id: "183195", token: "ALudQ" },
      { artist: "how", title: "Angelo Reira & Johann - Sandviken Hotell (b)", id: "183193", token: "CTq5y" },
      { artist: "how", title: "Jan Hakim & Johann - Stailings (a)", id: "183179", token: "LWVOl" },
      { artist: "how", title: "Jan Hakim & Johann - Stailings (b)", id: "183178", token: "eiAIW" },
      { artist: "how", title: "Lofi", id: "183173", token: "D9TSI" },
      { artist: "how", title: "Angelo Reira & Johann - Sandviken Hotell (a)", id: "182727", token: "QAuRq" }
    ];

    // UI helper
    const UI = (() => {
      const el = document.getElementById("ui");
      return { text: (t) => { if (el) el.textContent = t; } };
    })();

    // Audio engine (YouTube/WHYP embeds; visual uses synthetic bands for smoothness)
    class AudioEngine {
      constructor() {
        this.player = document.getElementById("player");
        this.started = false;
        this.muted = false;
        this.trackIndex = 0;
        this.tracks = [...YOUTUBE_TRACKS, ...WHYP_TRACKS];
        this.startMs = 0;
        this._advanceTimer = null;
      }
      loadAndPlay(track) {
        if (!this.player) return;
        const { id, token } = track;
        const src = token
          ? `https://whyp.it/tracks/embed?id=${id}&token=${token}`
          : `https://www.youtube.com/embed/${id}?autoplay=1&controls=0&disablekb=1&fs=0&iv_load_policy=3&modestbranding=1&rel=0&playsinline=1&mute=${this.muted?1:0}`;
        this.player.src = src;
        this.player.onload = () => {
          this.afterStart();
          setTimeout(() => { if (this.muted) UI.text(this.trackLabel() + " • muted"); }, 400);
        };
      }
      afterStart() {
        this.startMs = performance.now();
        clearTimeout(this._advanceTimer);
        this._advanceTimer = setTimeout(() => this.next(), 180000);
        UI.text(this.trackLabel());
      }
      next() { this.trackIndex = (this.trackIndex + 1) % this.tracks.length; this.loadAndPlay(this.tracks[this.trackIndex]); }
      prev() { this.trackIndex = (this.trackIndex - 1 + this.tracks.length) % this.tracks.length; this.loadAndPlay(this.tracks[this.trackIndex]); }
      toggleMute() {
        this.muted = !this.muted;
        if (this.started) {
          const t = this.tracks[this.trackIndex];
          if (!t.token) {
            this.player.src = `https://www.youtube.com/embed/${t.id}?autoplay=1&controls=0&disablekb=1&fs=0&iv_load_policy=3&modestbranding=1&rel=0&playsinline=1&mute=${this.muted?1:0}`;
          }
        }
        UI.text(this.trackLabel() + (this.muted ? " • muted" : ""));
      }
      trackLabel() { const t = this.tracks[this.trackIndex]; return `${t.artist} — ${t.title}`; }
      // Smooth pseudo-bands to keep animation elegant (no CORS capture from embeds)
      data() {
        const t = (performance.now() - this.startMs) * 0.001;
        const swing = Math.sin(t * 0.7) * 0.1, pocket = Math.cos(t * 0.5) * 0.08;
        const bass = Math.min(1, Math.max(0, 0.45 + 0.45 * Math.sin(2.2 * t + pocket)));
        const mid  = Math.min(1, Math.max(0, 0.40 + 0.35 * Math.sin(3.3 * t + swing)));
        const high = Math.min(1, Math.max(0, 0.30 + 0.35 * Math.sin(5.1 * t + pocket * 0.7)));
        const avg  = (bass + mid + high) / 3;
        return { bass, mid, high, average: avg };
      }
    }
    const audio = new AudioEngine();

    // Canvas + pixel buffer
    let w = 0, h = 0, canvas, ctx, imageData, data;
    canvas = document.getElementById("canvas");
    ctx = canvas.getContext("2d", { alpha: false });

    function onResize() {
      w = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
      h = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
      canvas.width = w; canvas.height = h;
      ctx.fillStyle = "#000"; ctx.fillRect(0, 0, w, h);
      imageData = ctx.getImageData(0, 0, w, h);
      data = imageData.data;
    }
    window.addEventListener("resize", onResize, false);

    // Classic pixel ops (assignment, no additive blend)
    function clearImageData() {
      for (let i = 0, n = data.length; i < n; i += 4) {
        data[i] = 0; data[i+1] = 0; data[i+2] = 0; data[i+3] = 255;
      }
    }
    function setPixel(x, y, r, g, b, a) {
      const i = (x + y * imageData.width) * 4;
      data[i] = r; data[i+1] = g; data[i+2] = b; data[i+3] = a;
    }
    function drawLine(x1, y1, x2, y2, r, g, b, a) {
      let dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1);
      let sx = (x1 < x2) ? 1 : -1, sy = (y1 < y2) ? 1 : -1;
      let err = dx - dy, lx = x1, ly = y1;
      while (true) {
        if (lx >= 0 && lx < w && ly >= 0 && ly < h) setPixel(lx, ly, r, g, b, a);
        if (lx === x2 && ly === y2) break;
        const e2 = err << 1;
        if (e2 > -dy) { err -= dy; lx += sx; }
        if (e2 < dx) { err += dx; ly += sy; }
      }
    }

    // Geometry and motion (classic)
    const fov = 250, speed = 0.75, SEGMENTS = 64, BASE_RADIUS = 75, Z_STEP = 4;
    let particles = [], centers = [];
    let time = 0;

    function getCirclePosition(cx, cy, radius, index, segments) {
      const angle = index * ((Math.PI * 2) / segments) + time;
      return { x: cx + Math.cos(angle) * radius, y: cy + Math.sin(angle) * radius };
    }
    function drawCircle(centerPos, radius, segments) {
      const coords = [];
      let radiusSave;
      let diff = 0;
      for (let i = 0; i <= segments; i++) {
        let radiusRandom = radius;
        if (i === 0) radiusSave = radiusRandom;
        if (i === segments) radiusRandom = radiusSave;
        const p = getCirclePosition(centerPos.x, centerPos.y, radiusRandom, i, segments);
        coords.push({ x: p.x, y: p.y, index: i + diff, radius: radiusRandom, segments, centerX: centerPos.x, centerY: centerPos.y });
      }
      return coords;
    }
    function addParticle(x, y, z, audioIndex) {
      return { x, y, z, x2d: 0, y2d: 0, audioBufferIndex: audioIndex, index: 0, radius: BASE_RADIUS, radiusAudio: BASE_RADIUS, segments: SEGMENTS, centerX: 0, centerY: 0 };
    }

    function addParticles() {
      let audioBufferIndexMin = 8;
      let audioBufferIndexMax = 1024;
      let audioIndex = audioBufferIndexMin;

      const centerPos = { x: 0, y: 0 };
      let c = 0;
      const w1 = Math.random() * w;
      const h1 = Math.random() * h;

      for (let z = -fov; z < fov; z += Z_STEP) {
        const coords = drawCircle(centerPos, BASE_RADIUS, SEGMENTS);
        const row = [];
        const center = { x: ((w / 2) - w1) * (c / 15) + w / 2, y: ((h / 2) - h1) * (c / 15) + h / 2 };
        c++;
        centers.push(center);

        audioIndex = Math.floor(Math.random() * audioBufferIndexMax) + audioBufferIndexMin;

        for (let i = 0, l = coords.length; i < l; i++) {
          const co = coords[i];
          const p = addParticle(co.x, co.y, z, audioIndex);
          p.index = co.index; p.radius = co.radius; p.radiusAudio = p.radius; p.segments = co.segments;
          p.centerX = co.centerX; p.centerY = co.centerY;
          row.push(p);
          if (i < coords.length / 2) audioIndex++; else audioIndex--;
          if (audioIndex > audioBufferIndexMax) audioIndex = audioBufferIndexMin;
          if (audioIndex < audioBufferIndexMin) audioIndex = audioBufferIndexMax;
        }
        particles.push(row);
      }
    }

    // Interaction
    let mouseActive = false, mouseDown = false;
    let mousePos = { x: 0, y: 0 }, mouseFollowSpeed = 0.015;

    function getMousePos(canvas, event) { const rect = canvas.getBoundingClientRect(); return { x: event.clientX - rect.left, y: event.clientY - rect.top }; }
    function mouseDownHandler() { mouseDown = true; setInversion(true); }
    function mouseUpHandler() { mouseDown = false; setInversion(false); }
    function mouseEnterHandler() { mouseActive = true; }
    function mouseLeaveHandler() { mouseActive = false; mousePos.x = w / 2; mousePos.y = h / 2; mouseDown = false; setInversion(false); }
    function mouseMoveHandler(event) { mousePos = getMousePos(canvas, event); }

    canvas.addEventListener('mousedown', mouseDownHandler, false);
    canvas.addEventListener('mouseup', mouseUpHandler, false);
    canvas.addEventListener('mousemove', mouseMoveHandler, false);
    canvas.addEventListener('mouseenter', mouseEnterHandler, false);
    canvas.addEventListener('mouseleave', mouseLeaveHandler, false);

    // Touch with ripple, swipe, double-tap
    let touchStartX = 0, touchStartY = 0, lastTapTime = 0;
    const swipeThreshold = 50, doubleTapMs = 300;
    const swipeHint = document.getElementById("swipeHint");

    function createRipple(x, y) {
      const ripple = document.createElement('div');
      ripple.className = 'touch-ripple';
      ripple.style.left = (x - 25) + 'px';
      ripple.style.top  = (y - 25) + 'px';
      document.body.appendChild(ripple);
      setTimeout(() => ripple.remove(), 600);
    }

    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const t = e.touches[0];
      const x = t.clientX - rect.left, y = t.clientY - rect.top;
      touchStartX = x; touchStartY = y;
      mousePos.x = x; mousePos.y = y;
      mouseDown = true; setInversion(true);
      createRipple(x, y);

      const now = performance.now();
      if (now - lastTapTime < doubleTapMs && audio.started) {
        audio.next(); UI.text(audio.trackLabel());
      }
      lastTapTime = now;
    }, { passive: false });

    canvas.addEventListener("touchmove", (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const t = e.touches[0];
      mousePos.x = t.clientX - rect.left; mousePos.y = t.clientY - rect.top;
    }, { passive: false });

    canvas.addEventListener("touchend", (e) => {
      e.preventDefault();
      mouseDown = false; setInversion(false);
      if (audio.started) {
        const rect = canvas.getBoundingClientRect();
        const t = e.changedTouches[0];
        const endX = t.clientX - rect.left, endY = t.clientY - rect.top;
        const dx = endX - touchStartX, dy = endY - touchStartY;
        if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > swipeThreshold) {
          if (dx > 0) audio.prev(); else audio.next();
          UI.text(audio.trackLabel());
          swipeHint.classList.add('show');
          setTimeout(() => swipeHint.classList.remove('show'), 1400);
        }
      }
    }, { passive: false });

    // Device orientation parallax
    let orientationActive = false, beta = 0, gamma = 0;
    if (window.DeviceOrientationEvent) {
      window.addEventListener("deviceorientation", (e) => {
        beta = e.beta || 0; gamma = e.gamma || 0; orientationActive = true;
      }, { passive: true });
    }

    // Overlay start + keyboard
    const overlay = document.getElementById("overlay");
    overlay.addEventListener("mousedown", (e) => { e.stopPropagation(); e.preventDefault(); }, { capture: true });
    overlay.addEventListener("click", (e) => { e.stopPropagation(); e.preventDefault(); startApp(); });
    overlay.addEventListener("keydown", (e) => { if (e.code === "Enter" || e.code === "Space") { e.preventDefault(); startApp(); } });

    addEventListener("keydown", (e) => {
      if (e.code === "Space") { e.preventDefault(); if (audio.started) { audio.next(); UI.text(audio.trackLabel()); } return; }
      if (e.key?.toLowerCase() === "m") { e.preventDefault(); if (audio.started) audio.toggleMute(); return; }
      if (e.code === "ArrowRight") { e.preventDefault(); if (audio.started) { audio.next(); UI.text(audio.trackLabel()); } return; }
      if (e.code === "ArrowLeft") { e.preventDefault(); if (audio.started) { audio.prev(); UI.text(audio.trackLabel()); } return; }
    });

    function startApp() {
      if (!audio.started) {
        audio.started = true;
        audio.loadAndPlay(audio.tracks[audio.trackIndex]);
        UI.text(audio.trackLabel());
        overlay.hidden = true;
      }
    }

    // Soft invert (progressive) + text state
    let colorInvertValue = 0;
    const siteTitle = document.getElementById("siteTitle");
    function setInversion(active) {
      // For text/UI, snap-mode like original press feedback
      if (active) {
        siteTitle.classList.add('site-inverted');
        document.getElementById('ui').classList.add('ui-inverted');
      } else {
        siteTitle.classList.remove('site-inverted');
        document.getElementById('ui').classList.remove('ui-inverted');
      }
    }
    function softInvert(value) {
      for (let j = 0, n = data.length; j < n; j += 4) {
        data[j]   = Math.abs(value - data[j]);
        data[j+1] = Math.abs(value - data[j+1]);
        data[j+2] = Math.abs(value - data[j+2]);
        data[j+3] = 255;
      }
    }

    // Render (clean, no additive trails; blue/teal wire tint like original)
    function renderFrame(a) {
      let needSort = false;
      const rows = particles.length;

      // Mouse/gyro parallax target
      let px = mousePos.x, py = mousePos.y;
      if (orientationActive && !mouseDown) {
        const sens = 1.25;
        px = w/2 + gamma * (w/90) * sens;
        py = h/2 + beta  * (h/90) * sens;
      }

      for (let i = 0; i < rows; i++) {
        const row = particles[i];
        const prevRow = (i > 0) ? particles[i-1] : null;
        const center = centers[i];

        if (mouseActive || mouseDown || orientationActive) {
          center.x = ((w / 2) - px) * ((row[0].z - fov) / 500) + w / 2;
          center.y = ((h / 2) - py) * ((row[0].z - fov) / 500) + h / 2;
        } else {
          center.x += ((w / 2) - center.x) * mouseFollowSpeed;
          center.y += ((h / 2) - center.y) * mouseFollowSpeed;
        }

        for (let j = 0, k = row.length; j < k; j++) {
          const p = row[j];
          const scale = fov / (fov + p.z);
          p.x2d = (p.x * scale) + center.x;
          p.y2d = (p.y * scale) + center.y;

          // Smooth audio radius lift (no analyser from embeds)
          p.radiusAudio = p.radius + a.average * 6;

          // Advance z with input modulation
          if (mouseDown) { p.z += speed; if (p.z > fov) { p.z -= (fov * 2); needSort = true; } }
          else           { p.z -= speed; if (p.z < -fov) { p.z += (fov * 2); needSort = true; } }

          // Line color by depth row (clean teal/blue)
          let lineColorValue = Math.round(i / rows * 180); // <= 180 to keep dimmer
          let b = lineColorValue;
          let g = Math.round(lineColorValue / 2);
          // draw around ring
          if (j > 0) {
            const pPrev = row[j - 1];
            drawLine(p.x2d | 0, p.y2d | 0, pPrev.x2d | 0, pPrev.y2d | 0, 0, g, b, 255);
          }

          // Move point along the ring for next frame
          let pos;
          if (j < k - 1) {
            pos = getCirclePosition(p.centerX, p.centerY, p.radiusAudio, p.index, p.segments);
          } else {
            const p1 = row[0];
            pos = getCirclePosition(p1.centerX, p1.centerY, p1.radiusAudio, p1.index, p1.segments);
          }
          p.x = pos.x; p.y = pos.y;

          // Diagonals to previous row
          if (i > 0 && i < rows - 1) {
            const pB = (j === 0) ? prevRow[prevRow.length - 1] : prevRow[j - 1];
            drawLine(p.x2d | 0, p.y2d | 0, pB.x2d | 0, pB.y2d | 0, 0, g, b, 255);
          }
        }
      }

      if (needSort) {
        particles = particles.sort((a, b) => (b[0].z - a[0].z));
      }

      // Time flow like original
      time += mouseDown ? -0.005 : 0.005;

      // Progressive soft invert on press/drag
      if (mouseDown) {
        colorInvertValue = Math.min(255, colorInvertValue + 5);
        softInvert(colorInvertValue);
      } else {
        colorInvertValue = Math.max(0, colorInvertValue - 5);
        if (colorInvertValue > 0) softInvert(colorInvertValue);
      }
    }

    function animate() {
      clearImageData();
      const a = audio.started ? audio.data() : { average: 0, bass: 0, mid: 0, high: 0 };
      renderFrame(a);
      ctx.putImageData(imageData, 0, 0);
      requestAnimationFrame(animate);
    }

    function boot() {
      onResize();
      addParticles();
      // initial clear + render to prime buffer
      clearImageData(); renderFrame({ average: 0, bass: 0, mid: 0, high: 0 }); ctx.putImageData(imageData, 0, 0);
      UI.text("Ready · click/touch to start");
      requestAnimationFrame(animate);
    }

    if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", boot);
    else boot();
  </script>
</body>
</html>
