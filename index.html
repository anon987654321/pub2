<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="mobile-web-app-capable" content="yes">
  <title>Radio Brgen</title>
  <meta name="theme-color" content="#000000">
  <meta name="description" content="Minimal audio-reactive warp tunnel with three-color gradient. Space next track. M mute/unmute. Mobile: swipe right for next track, touch for effects and tilt for parallax.">
  <link rel="manifest" href="manifest.json">
  <style>
    html, body { margin: 0; height: 100%; background: #000; color: #9aa; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    canvas { position: fixed; inset: 0; width: 100vw; height: 100vh; display: block; background: #000; touch-action: none; transition: filter 0.2s ease; }
    
    h1.site { 
      position: fixed; 
      top: 12px; 
      left: 12px; 
      margin: 0; 
      color: #fff; 
      letter-spacing: 0.02em; 
      pointer-events: none; 
      user-select: none; 
      font-weight: 700; 
      font-size: clamp(18px, 2.4vw, 26px);
      z-index: 100;
      transition: all 0.3s ease;
    }
    
    /* ENHANCEMENT: Color inversion affects all text */
    .canvas-inverted { filter: invert(1) hue-rotate(180deg); }
    .canvas-pulse { filter: brightness(1.5) saturate(1.2); }
    .site-pulse { color: #00ffff; transform: scale(1.05); }
    .text-inverted { color: #000; }
    .text-inverted.site-pulse { color: #ff3300; }
    
    .ui { 
      position: fixed; 
      right: 12px; 
      bottom: 10px; 
      color: #7a90a0; 
      font-size: 12px; 
      opacity: 0.95; 
      white-space: nowrap; 
      pointer-events: none; 
      user-select: none; 
      text-align: right; 
      max-width: min(72vw, 800px); 
      overflow: hidden; 
      text-overflow: ellipsis;
      z-index: 100;
      transition: all 0.3s ease;
    }
    
    .overlay { 
      position: fixed; 
      inset: 0; 
      display: grid; 
      place-items: center; 
      background: rgba(0,0,0,0.9); 
      color: #9aa; 
      cursor: pointer; 
      user-select: none;
      z-index: 1000;
      transition: all 0.3s ease;
    }
    
    .overlay[hidden] { display: none; }
    
    #player { 
      position: fixed; 
      top: -1000px; 
      left: -1000px; 
      width: 1px; 
      height: 1px; 
      opacity: 0; 
      pointer-events: none; 
    }
    
    .touch-ripple {
      position: absolute;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
      pointer-events: none;
      animation: ripple 0.6s ease-out forwards;
      z-index: 50;
    }
    
    /* ENHANCEMENT: Swipe indicator for mobile */
    .swipe-hint {
      position: fixed;
      bottom: 50px;
      right: 20px;
      color: rgba(255,255,255,0.3);
      font-size: 10px;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 99;
      pointer-events: none;
    }
    
    .swipe-hint.show { opacity: 1; }
    
    @keyframes ripple {
      0% { transform: scale(0); opacity: 1; }
      100% { transform: scale(4); opacity: 0; }
    }
    
    @media (prefers-reduced-motion: reduce) { 
      * { animation: none !important; transition: none !important; }
      .touch-ripple { display: none; }
    }
  </style>
</head>
<body>
  <h1 class="site" id="siteTitle" aria-hidden="true">radio.brgen.no</h1>
  <canvas id="canvas" aria-label="Audio-reactive warp tunnel visualizer"></canvas>
  <div id="overlay" class="overlay" role="dialog" aria-labelledby="start-title" tabindex="0">
    <h2 id="start-title" style="position:absolute;left:-9999px;">Start Visualization</h2>
    <p>Click / tap to start · Space next track · Mobile: swipe right for next track</p>
  </div>
  <div class="ui" id="ui">Ready</div>
  <div class="swipe-hint" id="swipeHint">→ swipe for next track</div>
  <iframe id="player" src="about:blank" frameborder="0" allow="autoplay; encrypted-media; accelerometer; gyroscope"></iframe>
  <script>
    "use strict";
    
    // PRESERVE EXACT: Three-color gradient system
    const COLOR_A = { h: 210, s: 40, l: 16 };
    const COLOR_B = { h: 190, s: 50, l: 38 };
    const COLOR_C = { h: 180, s: 30, l: 28 };
    
    // ENHANCEMENT: Expanded effects state management
    const EffectsState = {
      colorInverted: false,
      pulsing: false,
      touchActive: false,
      gyroStrength: 0,
      tunnelEndpoint: { x: 0, y: 0 },
      breathingPhase: 0,
      chromaticStrength: 0,
      
      invertColors() {
        this.colorInverted = !this.colorInverted;
        const canvas = document.getElementById('canvas');
        const siteTitle = document.getElementById('siteTitle');
        const ui = document.getElementById('ui');
        const overlay = document.getElementById('overlay');
        
        if (this.colorInverted) {
          canvas.classList.add('canvas-inverted');
          siteTitle.classList.add('site-pulse', 'text-inverted');
          ui.classList.add('text-inverted');
          overlay.classList.add('text-inverted');
        } else {
          canvas.classList.remove('canvas-inverted');
          siteTitle.classList.remove('site-pulse', 'text-inverted');
          ui.classList.remove('text-inverted');
          overlay.classList.remove('text-inverted');
        }
      },
      
      pulse(duration = 200) {
        if (this.pulsing) return;
        this.pulsing = true;
        const canvas = document.getElementById('canvas');
        canvas.classList.add('canvas-pulse');
        
        setTimeout(() => {
          canvas.classList.remove('canvas-pulse');
          this.pulsing = false;
        }, duration);
      },
      
      createRipple(x, y) {
        const ripple = document.createElement('div');
        ripple.className = 'touch-ripple';
        ripple.style.left = (x - 25) + 'px';
        ripple.style.top = (y - 25) + 'px';
        ripple.style.width = '50px';
        ripple.style.height = '50px';
        document.body.appendChild(ripple);
        
        setTimeout(() => {
          if (ripple.parentNode) {
            ripple.parentNode.removeChild(ripple);
          }
        }, 600);
      },
      
      // ENHANCEMENT: Update tunnel endpoint for parallax
      updateTunnelEndpoint(mouseX, mouseY, w, h) {
        const targetX = (mouseX - w/2) * 0.15;
        const targetY = (mouseY - h/2) * 0.15;
        this.tunnelEndpoint.x += (targetX - this.tunnelEndpoint.x) * 0.08;
        this.tunnelEndpoint.y += (targetY - this.tunnelEndpoint.y) * 0.08;
      }
    };
    
    // ENHANCEMENT: Particle system for ambient effects
    class TunnelParticle {
      constructor() {
        this.reset();
      }
      
      reset() {
        this.x = (Math.random() - 0.5) * 400;
        this.y = (Math.random() - 0.5) * 400;
        this.z = Math.random() * 500 - 250;
        this.life = 1.0;
        this.decay = 0.003 + Math.random() * 0.007;
        this.size = 1 + Math.random() * 3;
        this.hue = Math.random() * 60 + 180;
      }
      
      update(dt, audioAvg) {
        this.z += (50 + audioAvg * 100) * dt;
        this.life -= this.decay;
        
        if (this.life <= 0 || this.z > 250) {
          this.reset();
          this.z = -250;
        }
      }
      
      draw(ctx, w, h, tunnelEndpoint) {
        if (this.z <= -250) return;
        
        const scale = 250 / (250 + this.z);
        const screenX = this.x * scale + w/2 + tunnelEndpoint.x * scale;
        const screenY = this.y * scale + h/2 + tunnelEndpoint.y * scale;
        
        if (screenX < 0 || screenX >= w || screenY < 0 || screenY >= h) return;
        
        const alpha = Math.floor(this.life * 100 * scale);
        if (alpha <= 0) return;
        
        const [r, g, b] = hslToRgb(this.hue, 70, 50);
        const size = this.size * scale;
        
        for (let dx = -size; dx <= size; dx++) {
          for (let dy = -size; dy <= size; dy++) {
            const dist = Math.hypot(dx, dy);
            if (dist <= size) {
              const px = Math.floor(screenX + dx);
              const py = Math.floor(screenY + dy);
              if (px >= 0 && px < w && py >= 0 && py < h) {
                const i = (px + py * w) * 4;
                const falloff = 1 - (dist / size);
                const particleAlpha = alpha * falloff;
                setPixel(px, py, r, g, b, particleAlpha);
              }
            }
          }
        }
      }
    }
    
    // ENHANCEMENT: Create particle instances
    const particles = [];
    for (let i = 0; i < 25; i++) {
      particles.push(new TunnelParticle());
    }
    
    const GRAD = {
      phase: 0,
      speedBase: 0.08,
      mouseDelta: 0,
      colorShift: 0,
      
      update(dt, audioAvg, mouseDx, mouseDy) {
        this.mouseDelta = Math.hypot(mouseDx || 0, mouseDy || 0) * 0.01;
        this.phase += dt * (this.speedBase + audioAvg * 0.12 + this.mouseDelta * 0.2);
        
        // ENHANCEMENT: Chromatic aberration from movement
        EffectsState.chromaticStrength = Math.min(1, this.mouseDelta * 5);
        
        // ENHANCEMENT: Breathing effect
        EffectsState.breathingPhase += dt * (2 + audioAvg * 4);
        
        const effectMultiplier = EffectsState.colorInverted ? -1 : 1;
        const targetShift = audioAvg * 30 * effectMultiplier + EffectsState.gyroStrength * 20;
        this.colorShift += (targetShift - this.colorShift) * 0.2;
        
        COLOR_A.h = (210 + this.colorShift) % 360;
        COLOR_B.h = (190 + this.colorShift * 0.7) % 360;
        COLOR_C.h = (180 + this.colorShift * 0.5) % 360;
        COLOR_B.s = Math.min(80, 50 + audioAvg * 30);
      },
      
      factor(depth, audioAvg) {
        let f = 1 - depth;
        f += 0.06 * Math.sin(this.phase + depth * 1.2);
        f += 0.05 * (audioAvg || 0);
        f += 0.03 * this.mouseDelta;
        
        // ENHANCEMENT: Breathing effect integration
        f += 0.02 * Math.sin(EffectsState.breathingPhase) * audioAvg;
        
        if (EffectsState.pulsing) {
          f += 0.15 * Math.sin(this.phase * 8);
        }
        
        return Math.max(0, Math.min(1, f));
      }
    };
    
    function hslToRgb(h, s, l) {
      h = ((h % 360) + 360) % 360;
      s = Math.max(0, Math.min(100, s)) / 100;
      l = Math.max(0, Math.min(100, l)) / 100;
      const c = (1 - Math.abs(2 * l - 1)) * s;
      const hp = h / 60;
      const x = c * (1 - Math.abs((hp % 2) - 1));
      let r1=0,g1=0,b1=0;
      if (0<=hp && hp<1){ r1=c; g1=x; b1=0; } else if (1<=hp && hp<2){ r1=x; g1=c; b1=0; } else if (2<=hp && hp<3){ r1=0; g1=c; b1=x; }
      else if (3<=hp && hp<4){ r1=0; g1=x; b1=c; } else if (4<=hp && hp<5){ r1=x; g1=0; b1=c; } else if (5<=hp && hp<6){ r1=c; g1=0; b1=x; }
      const m = l - c/2;
      return [Math.round((r1 + m) * 255) | 0, Math.round((g1 + m) * 255) | 0, Math.round((b1 + m) * 255) | 0];
    }
    
    function colorFor(depth, audioAvg) {
      const f = GRAD.factor(depth, audioAvg);
      let h, s, lBase;
      if (f < 0.5) {
        const t = f * 2;
        h = COLOR_A.h + (COLOR_B.h - COLOR_A.h) * t;
        s = COLOR_A.s + (COLOR_B.s - COLOR_A.s) * t;
        lBase = COLOR_A.l + (COLOR_B.l - COLOR_A.l) * t;
      } else {
        const t = (f - 0.5) * 2;
        h = COLOR_B.h + (COLOR_C.h - COLOR_B.h) * t;
        s = COLOR_B.s + (COLOR_C.s - COLOR_B.s) * t;
        lBase = COLOR_B.l + (COLOR_C.l - COLOR_B.l) * t;
      }
      const l = lBase + (audioAvg || 0) * 3;
      return hslToRgb(h, s, l);
    }
    
    const WIRE_ALPHA = 200;
    const FOV = 250, SPEED = 0.75, BASE_RADIUS = 75, SEGMENTS = 64, Z_STEP = 4;
    
    // PRESERVE EXACT: YOUR CURATED TRACKS
    const YOUTUBE_TRACKS = [
      { artist: "J Dilla", title: "Microphone Master", id: "9EGHwkDix78" },
      { artist: "AFTA-1", title: "Due Time", id: "WC09qDzU9y4" },
      { artist: "Flying Lotus", title: "Message Situation", id: "9fzGGbiJags" },
      { artist: "Röyksopp", title: "Only This Moment (Forsiktige massage)", id: "vLE5XCc0XO8" },
      { artist: "Jneiro Jarel", title: "Chinubian", id: "9OPypHXlJUQ" },
      { artist: "Pete Rock", title: "A Little Soul", id: "4tY89H5TWPY" },
      { artist: "Slum Village", title: "La La (Instrumental)", id: "EYJxxHQ7sX0" },
      { artist: "Slum Village", title: "Forth & Back (Rock Music) Instrumental", id: "1XY8EHOzLbY" },
      { artist: "Flying Lotus", title: "me Yesterday//Corded", id: "8DgAhgmpXNA" },
      { artist: "Flying Lotus", title: "Camel", id: "t6SXXx1Fu_4" },
      { artist: "Slum Village", title: "Worlds Full of Sadness", id: "MU3nfxsz2XA" },
      { artist: "Black Loops", title: "Under the Sea", id: "U81xh9gJeYM" }
    ];
    
    const WHYP_TRACKS = [
      { artist: "how", title: "J Dilla - Players (Second Version) (Unreleased)", id: "292777", token: "zaB8x" },
      { artist: "how", title: "Black Loops - Under the Sea [U81xh9gJeYM]", id: "292774", token: "UTbNQ" },
      { artist: "how", title: "amiga", id: "292741", token: "2Jh5p" },
      { artist: "how", title: "RADIO BERGEN #1", id: "292718", token: "1cr3I" },
      { artist: "how", title: "RAUINGAR", id: "230366", token: "zPfQp" },
      { artist: "how", title: "Haisam & Johann - PB1", id: "195489", token: "3XYFb" },
      { artist: "how", title: "Mike T & Johann - Alt Kan Skje", id: "183204", token: "20RKB" },
      { artist: "how", title: "Jan Hakim & Johann - Stailings (a)", id: "183195", token: "ALudQ" },
      { artist: "how", title: "Angelo Reira & Johann - Sandviken Hotell (b)", id: "183193", token: "CTq5y" },
      { artist: "how", title: "Jan Hakim & Johann - Stailings (a)", id: "183179", token: "LWVOl" },
      { artist: "how", title: "Jan Hakim & Johann - Stailings (b)", id: "183178", token: "eiAIW" },
      { artist: "how", title: "Lofi", id: "183173", token: "D9TSI" },
      { artist: "how", title: "Angelo Reira & Johann - Sandviken Hotell (a)", id: "182727", token: "QAuRq" }
    ];
    
    const UI = (() => {
      const el = document.getElementById("ui");
      return { text: (t) => { if (el) el.textContent = t; } };
    })();
    
    // PRESERVE EXACT: AudioEngine class
    class AudioEngine {
      constructor() {
        this.player = document.getElementById("player");
        this.started = false;
        this.muted = false;
        this.trackIndex = 0;
        this.tracks = [...YOUTUBE_TRACKS, ...WHYP_TRACKS];
        this.startMs = 0;
        this._advanceTimer = null;
      }
      loadAndPlay(track) {
        if (!this.player) return;
        const { id, token } = track;
        let src;
        if (token) {
          src = `https://whyp.it/tracks/embed?id=${id}&token=${token}`;
        } else {
          src = `https://www.youtube.com/embed/${id}?autoplay=1&controls=0&disablekb=1&fs=0&iv_load_policy=3&modestbranding=1&rel=0&playsinline=1&mute=${this.muted ? 1 : 0}`;
        }
        this.player.src = src;
        this.player.onload = () => {
          this.afterStart();
          setTimeout(() => {
            if (this.muted) UI.text(this.trackLabel() + " • muted (press M)");
          }, 600);
        };
      }
      afterStart() {
        this.startMs = performance.now();
        clearTimeout(this._advanceTimer);
        this._advanceTimer = setTimeout(() => this.next(), 180000);
        UI.text(this.trackLabel());
      }
      next() {
        this.trackIndex = (this.trackIndex + 1) % this.tracks.length;
        this.loadAndPlay(this.tracks[this.trackIndex]);
        
        // ENHANCEMENT: Show swipe hint briefly on mobile
        if (isMobile) {
          const hint = document.getElementById('swipeHint');
          hint.classList.add('show');
          setTimeout(() => hint.classList.remove('show'), 2000);
        }
      }
      toggleMute() {
        this.muted = !this.muted;
        if (this.started) {
          const track = this.tracks[this.trackIndex];
          if (!track.token) {
            const src = `https://www.youtube.com/embed/${track.id}?autoplay=1&controls=0&disablekb=1&fs=0&iv_load_policy=3&modestbranding=1&rel=0&playsinline=1&mute=${this.muted ? 1 : 0}`;
            this.player.src = src;
          }
        }
        UI.text(this.trackLabel() + (this.muted ? " • muted" : ""));
      }
      trackLabel() { const t = this.tracks[this.trackIndex]; return `${t.artist} — ${t.title}`; }
      data() {
        const t = (performance.now() - this.startMs) * 0.001;
        const swing = Math.sin(t * 0.7) * 0.1, pocket = Math.cos(t * 0.5) * 0.08;
        const bass = Math.min(1, Math.max(0, 0.45 + 0.45 * Math.sin(2.2 * t + pocket)));
        const mid = Math.min(1, Math.max(0, 0.40 + 0.35 * Math.sin(3.3 * t + swing)));
        const high = Math.min(1, Math.max(0, 0.30 + 0.35 * Math.sin(5.1 * t + pocket * 0.7)));
        const avg = (bass + mid + high) / 3;
        return { bass, mid, high, average: avg };
      }
    }
    
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d", { alpha: false });
    let w = 0, h = 0, imageData = null, data = null;
    const isMobile = /Android|iPhone|iPad/i.test(navigator.userAgent);
    
    function resize() {
      w = window.innerWidth | 0; h = window.innerHeight | 0;
      canvas.width = w; canvas.height = h;
      ctx.fillStyle = "#000"; ctx.fillRect(0, 0, w, h);
      imageData = ctx.getImageData(0, 0, w, h);
      data = imageData.data;
    }
    addEventListener("resize", resize);
    
    function fadeImageData(fade = 0.85) {
      for (let i = 0, n = data.length; i < n; i += 4) {
        data[i] *= fade; data[i+1] *= fade; data[i+2] *= fade; data[i+3] = 255;
      }
    }
    
    // ENHANCEMENT: Improved setPixel for particle system
    function setPixel(x, y, r, g, b, a) {
      if (x >= 0 && x < w && y >= 0 && y < h && a > 0) {
        const i = (x + y * w) * 4;
        const alpha = a / 255;
        data[i] = Math.min(255, data[i] + r * alpha);
        data[i+1] = Math.min(255, data[i+1] + g * alpha);
        data[i+2] = Math.min(255, data[i+2] + b * alpha);
        data[i+3] = 255;
      }
    }
    
    // ENHANCEMENT: Chromatic aberration line drawing
    function drawLineChromatic(x1, y1, x2, y2, r, g, b, a, chromaticStrength = 0) {
      if (chromaticStrength > 0.1) {
        const offset = chromaticStrength * 2;
        drawLine(x1 - offset, y1, x2 - offset, y2, r, 0, 0, a);
        drawLine(x1, y1, x2, y2, 0, g, 0, a);
        drawLine(x1 + offset, y1, x2 + offset, y2, 0, 0, b, a);
      } else {
        drawLine(x1, y1, x2, y2, r, g, b, a);
      }
    }
    
    function drawLine(x1, y1, x2, y2, r, g, b, a) {
      x1 = Math.max(0, Math.min(w-1, x1 | 0)); y1 = Math.max(0, Math.min(h-1, y1 | 0));
      x2 = Math.max(0, Math.min(w-1, x2 | 0)); y2 = Math.max(0, Math.min(h-1, y2 | 0));
      let dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1);
      let sx = x1 < x2 ? 1 : -1, sy = y1 < y2 ? 1 : -1;
      let err = dx - dy, x = x1, y = y1;
      for (;;) {
        if (x >= 0 && x < w && y >= 0 && y < h) {
          const i = (x + y * w) * 4;
          data[i]=r; data[i+1]=g; data[i+2]=b; data[i+3]=a;
        }
        if (x === x2 && y === y2) break;
        const e2 = err << 1;
        if (e2 > -dy) { err -= dy; x += sx; }
        if (e2 < dx) { err += dx; y += sy; }
      }
    }
    
    let time = 0;
    let mouseActive = false, mouseDown = false;
    let mouseX = 0, mouseY = 0, lastMouseX = 0, lastMouseY = 0;
    let rows = []; let centers = [];
    
    function initField() {
      rows = []; centers = [];
      let c = 0;
      const w1 = Math.random() * w, h1 = Math.random() * h;
      for (let z = -FOV; z < FOV; z += Z_STEP) {
        const row = [];
        for (let i = 0; i < SEGMENTS; i++) {
          row.push({ x:0, y:0, z, x2d:0, y2d:0, idx:i, segs:SEGMENTS, radius:BASE_RADIUS, radiusAudio:BASE_RADIUS });
        }
        rows.push(row);
        centers.push({
          x: ((w / 2) - w1) * (c / 15) + w / 2,
          y: ((h / 2) - h1) * (c / 15) + h / 2
        });
        c++;
      }
    }
    
    const TAU = Math.PI * 2;
    const ringShapeFn = (th,i,p,a) => 0;
    const diagEvery = 1;
    const twist = 1.0;
    
    const overlay = document.getElementById("overlay");
    const audio = new AudioEngine();
    
    // ENHANCEMENT: Touch gesture handling for mobile track switching
    let touchStartX = 0;
    let touchStartY = 0;
    let swipeThreshold = 50;
    
    function handleInteraction(x, y, isTouch = false) {
      if (isTouch) {
        EffectsState.createRipple(x, y);
        EffectsState.pulse(300);
      } else {
        EffectsState.invertColors();
        EffectsState.pulse(150);
      }
    }
    
    overlay.addEventListener("mousedown", (e) => { e.stopPropagation(); e.preventDefault(); }, { capture: true });
    overlay.addEventListener("click", (e) => { e.stopPropagation(); e.preventDefault(); startApp(); });
    overlay.addEventListener("keydown", (e) => { if (e.code === "Enter" || e.code === "Space") { e.preventDefault(); startApp(); } });
    
    canvas.addEventListener("mousedown", (e) => { 
      mouseDown = true;
      const rect = canvas.getBoundingClientRect();
      handleInteraction(e.clientX - rect.left, e.clientY - rect.top, false);
    });
    canvas.addEventListener("mouseup", () => { mouseDown = false; });
    canvas.addEventListener("mouseenter",() => { mouseActive = true; });
    canvas.addEventListener("mouseleave",() => { mouseActive = false; mouseDown = false; mouseX = w/2; mouseY = h/2; });
    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      lastMouseX = mouseX; lastMouseY = mouseY;
      mouseX = e.clientX - rect.left; mouseY = e.clientY - rect.top;
    }, { passive: true });
    
    // ENHANCEMENT: Advanced touch handling with swipe detection
    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      EffectsState.touchActive = true;
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      
      touchStartX = x;
      touchStartY = y;
      
      handleInteraction(x, y, true);
      mouseX = x; mouseY = y;
      mouseActive = true;
      mouseDown = true;
    }, { passive: false });
    
    canvas.addEventListener("touchmove", (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      lastMouseX = mouseX; lastMouseY = mouseY;
      mouseX = touch.clientX - rect.left;
      mouseY = touch.clientY - rect.top;
    }, { passive: false });
    
    canvas.addEventListener("touchend", (e) => {
      e.preventDefault();
      
      // ENHANCEMENT: Swipe detection for track switching
      const deltaX = mouseX - touchStartX;
      const deltaY = mouseY - touchStartY;
      
      if (Math.abs(deltaX) > swipeThreshold && Math.abs(deltaX) > Math.abs(deltaY)) {
        if (deltaX > 0 && audio.started) {
          audio.next(); // Swipe right = next track
        }
      }
      
      EffectsState.touchActive = false;
      mouseDown = false;
    }, { passive: false });
    
    let orientationActive = false;
    let alpha = 0, beta = 0, gamma = 0;
    if (window.DeviceOrientationEvent) {
      window.addEventListener("deviceorientation", (e) => {
        alpha = e.alpha || 0; 
        beta = e.beta || 0; 
        gamma = e.gamma || 0;
        orientationActive = true;
        EffectsState.gyroStrength = Math.min(1, Math.hypot(beta, gamma) / 90);
      }, { passive: true });
    }
    
    addEventListener("keydown", (e) => {
      if (e.code === "Space") { e.preventDefault(); if (audio.started) audio.next(); return; }
      if (e.key?.toLowerCase() === "m") { e.preventDefault(); if (audio.started) audio.toggleMute(); return; }
      if (e.key?.toLowerCase() === "i") { e.preventDefault(); EffectsState.invertColors(); return; }
    });
    
    function startApp() {
      if (!audio.started) {
        audio.started = true;
        audio.loadAndPlay(audio.tracks[audio.trackIndex]);
        UI.text(audio.trackLabel());
        overlay.hidden = true;
        
        // Show swipe hint on mobile
        if (isMobile) {
          setTimeout(() => {
            const hint = document.getElementById('swipeHint');
            hint.classList.add('show');
            setTimeout(() => hint.classList.remove('show'), 3000);
          }, 2000);
        }
      }
    }
    
    function projectAndAdvance(audioData, dt, mouseDx, mouseDy) {
      const R = rows.length;
      let sortNeeded = false;
      GRAD.update(dt, audioData.average, mouseDx, mouseDy);
      
      // ENHANCEMENT: Update tunnel endpoint for parallax effect
      EffectsState.updateTunnelEndpoint(mouseX, mouseY, w, h);
      
      // ENHANCEMENT: Update particles
      particles.forEach(p => p.update(dt, audioData.average));
      
      for (let i = 0; i < R; i++) {
        const row = rows[i];
        const prevRow = i > 0 ? rows[i - 1] : null;
        const center = centers[i];
        
        // ENHANCEMENT: Tunnel endpoint parallax
        const depthFactor = (row[0].z + FOV) / (FOV * 2);
        const endpointInfluence = 1 - depthFactor;
        
        if (mouseActive || EffectsState.touchActive) {
          const parallaxStrength = EffectsState.touchActive ? 1.5 : 1.0;
          center.x = ((w / 2) - mouseX) * ((row[0].z - FOV) / 500) * parallaxStrength + w / 2;
          center.y = ((h / 2) - mouseY) * ((row[0].z - FOV) / 500) * parallaxStrength + h / 2;
          
          // Apply endpoint movement
          center.x += EffectsState.tunnelEndpoint.x * endpointInfluence;
          center.y += EffectsState.tunnelEndpoint.y * endpointInfluence;
        } else {
          center.x += ((w / 2) - center.x) * 0.015;
          center.y += ((h / 2) - center.y) * 0.015;
          
          // Gentle endpoint drift
          center.x += EffectsState.tunnelEndpoint.x * endpointInfluence * 0.5;
          center.y += EffectsState.tunnelEndpoint.y * endpointInfluence * 0.5;
        }
        
        const depth = i / R;
        const [cr, cg, cb] = colorFor(depth, audioData.average);
        const ca = WIRE_ALPHA;
        
        for (let j = 0, k = row.length; j < k; j++) {
          const p = row[j];
          const theta = p.idx * (TAU / p.segs) + time * twist;
          const rShape = ringShapeFn(theta, i, p, audioData);
          
          // ENHANCEMENT: Audio-reactive breathing
          const breathingEffect = Math.sin(EffectsState.breathingPhase + depth * Math.PI) * audioData.average * 8;
          p.radius = BASE_RADIUS + rShape + breathingEffect;
          p.radiusAudio = p.radius + audioData.average * 6;
          
          if (EffectsState.touchActive) {
            p.radiusAudio += 10;
          }
          
          const rx = Math.cos(theta) * p.radiusAudio;
          const ry = Math.sin(theta) * p.radiusAudio;
          const scale = Math.max(0.001, Math.min(10, FOV / (FOV + p.z)));
          p.x2d = (rx * scale) + center.x;
          p.y2d = (ry * scale) + center.y;
          
          if (mouseDown) { 
            p.z += SPEED * (EffectsState.touchActive ? 1.5 : 1.0); 
            if (p.z > FOV) { p.z -= (FOV * 2); sortNeeded = true; } 
          } else { 
            p.z -= SPEED; 
            if (p.z < -FOV) { p.z += (FOV * 2); sortNeeded = true; } 
          }
          
          const prevIdx = (j > 0 ? j - 1 : k - 1);
          const prev = row[prevIdx];
          
          // ENHANCEMENT: Use chromatic aberration on fast movement
          drawLineChromatic(p.x2d, p.y2d, prev.x2d, prev.y2d, cr, cg, cb, ca, EffectsState.chromaticStrength);
          
          if (prevRow && (j % diagEvery === 0)) {
            const prevInPrev = prevRow[prevIdx];
            drawLineChromatic(p.x2d, p.y2d, prevInPrev.x2d, prevInPrev.y2d, cr, cg, cb, ca * 0.7, EffectsState.chromaticStrength * 0.5);
          }
        }
      }
      
      // ENHANCEMENT: Draw particles
      particles.forEach(p => p.draw(ctx, w, h, EffectsState.tunnelEndpoint));
      
      if (sortNeeded) {
        const pairs = rows.map((row, idx) => ({ row, center: centers[idx] }));
        pairs.sort((a, b) => b.row[0].z - a.row[0].z);
        rows = pairs.map(p => p.row);
        centers = pairs.map(p => p.center);
      }
      
      time += mouseDown ? -0.005 : 0.005;
    }
    
    let lastTs = performance.now();
    function animate(ts) {
      const dt = Math.min(0.05, (ts - lastTs) / 1000);
      lastTs = ts;
      
      fadeImageData(0.85);
      const a = audio.data();
      const mouseDx = mouseX - lastMouseX, mouseDy = mouseY - lastMouseY;
      
      if (orientationActive && !EffectsState.touchActive) {
        const gyroSensitivity = 1.2;
        mouseX = w / 2 + gamma * (w / 90) * gyroSensitivity;
        mouseY = h / 2 + beta * (h / 90) * gyroSensitivity;
        mouseActive = true;
      }
      
      projectAndAdvance(a, dt, mouseDx, mouseDy);
      ctx.putImageData(imageData, 0, 0);
      requestAnimationFrame(animate);
    }
    
    function boot() { 
      resize(); 
      initField(); 
      UI.text("Ready · click/touch to start"); 
      requestAnimationFrame(animate); 
    }
    
    if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", boot); else boot();
  </script>
</body>
</html>
